"use strict";(globalThis.webpackChunkdefogv_2_wiki=globalThis.webpackChunkdefogv_2_wiki||[]).push([[9794],{1470:(e,r,n)=>{n.d(r,{A:()=>C});var i=n(6540),s=n(4164),t=n(7559),l=n(3104),a=n(6347),c=n(205),o=n(7485),d=n(1682),h=n(679);function u(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:r,children:n}=e;return(0,i.useMemo)(()=>{const e=r??function(e){return u(e).map(({props:{value:e,label:r,attributes:n,default:i}})=>({value:e,label:r,attributes:n,default:i}))}(n);return function(e){const r=(0,d.XI)(e,(e,r)=>e.value===r.value);if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[r,n])}function x({value:e,tabValues:r}){return r.some(r=>r.value===e)}function j({queryString:e=!1,groupId:r}){const n=(0,a.W6)(),s=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,o.aZ)(s),(0,i.useCallback)(e=>{if(!s)return;const r=new URLSearchParams(n.location.search);r.set(s,e),n.replace({...n.location,search:r.toString()})},[s,n])]}function m(e){const{defaultValue:r,queryString:n=!1,groupId:s}=e,t=p(e),[l,a]=(0,i.useState)(()=>function({defaultValue:e,tabValues:r}){if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=r.find(e=>e.default)??r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:r,tabValues:t})),[o,d]=j({queryString:n,groupId:s}),[u,m]=function({groupId:e}){const r=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,s]=(0,h.Dv)(r);return[n,(0,i.useCallback)(e=>{r&&s.set(e)},[r,s])]}({groupId:s}),g=(()=>{const e=o??u;return x({value:e,tabValues:t})?e:null})();(0,c.A)(()=>{g&&a(g)},[g]);return{selectedValue:l,selectValue:(0,i.useCallback)(e=>{if(!x({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);a(e),d(e),m(e)},[d,m,t]),tabValues:t}}var g=n(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=n(4848);function b({className:e,block:r,selectedValue:n,selectValue:i,tabValues:t}){const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.a_)(),o=e=>{const r=e.currentTarget,s=a.indexOf(r),l=t[s].value;l!==n&&(c(r),i(l))},d=e=>{let r=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const n=a.indexOf(e.currentTarget)+1;r=a[n]??a[0];break}case"ArrowLeft":{const n=a.indexOf(e.currentTarget)-1;r=a[n]??a[a.length-1];break}}r?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":r},e),children:t.map(({value:e,label:r,attributes:i})=>(0,y.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{a.push(e)},onKeyDown:d,onClick:o,...i,className:(0,s.A)("tabs__item",v.tabItem,i?.className,{"tabs__item--active":n===e}),children:r??e},e))})}function f({lazy:e,children:r,selectedValue:n}){const t=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){const e=t.find(e=>e.props.value===n);return e?(0,i.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:t.map((e,r)=>(0,i.cloneElement)(e,{key:r,hidden:e.props.value!==n}))})}function k(e){const r=m(e);return(0,y.jsxs)("div",{className:(0,s.A)(t.G.tabs.container,"tabs-container",v.tabList),children:[(0,y.jsx)(b,{...r,...e}),(0,y.jsx)(f,{...r,...e})]})}function C(e){const r=(0,g.A)();return(0,y.jsx)(k,{...e,children:u(e.children)},String(r))}},4135:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"local-setup/linkerd","title":"Linkerd Service Mesh","description":"Understanding Linkerd service mesh architecture and capabilities","source":"@site/docs/local-setup/linkerd.mdx","sourceDirName":"local-setup","slug":"/local-setup/linkerd","permalink":"/defogv2-wiki/docs/local-setup/linkerd","draft":false,"unlisted":false,"editUrl":"https://github.com/aprountzos/defogv2-wiki/tree/main/docs/docs/local-setup/linkerd.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Linkerd Service Mesh","description":"Understanding Linkerd service mesh architecture and capabilities","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Translate your site","permalink":"/defogv2-wiki/docs/tutorial-extras/translate-your-site"}}');var s=n(4848),t=n(8453),l=n(1470),a=n(9365);const c={title:"Linkerd Service Mesh",description:"Understanding Linkerd service mesh architecture and capabilities",sidebar_position:2},o="Linkerd Service Mesh",d={},h=[{value:"What is a Service Mesh?",id:"what-is-a-service-mesh",level:2},{value:"Why Linkerd?",id:"why-linkerd",level:2},{value:"How Linkerd Works",id:"how-linkerd-works",level:2},{value:"The Sidecar Pattern",id:"the-sidecar-pattern",level:3},{value:"Linkerd Architecture",id:"linkerd-architecture",level:2},{value:"Control Plane Components",id:"control-plane-components",level:3},{value:"Data Plane: The Proxy",id:"data-plane-the-proxy",level:3},{value:"Key Features Explained",id:"key-features-explained",level:2},{value:"1. Automatic Mutual TLS (mTLS)",id:"1-automatic-mutual-tls-mtls",level:3},{value:"2. Traffic Management",id:"2-traffic-management",level:3},{value:"3. Observability",id:"3-observability",level:3},{value:"4. Reliability",id:"4-reliability",level:3},{value:"Linkerd Components &amp; Extensions",id:"linkerd-components--extensions",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Multi-Cluster Communication",id:"multi-cluster-communication",level:2},{value:"The Problem",id:"the-problem",level:3},{value:"The Solution: Linkerd Multicluster",id:"the-solution-linkerd-multicluster",level:3},{value:"How It Works: Step by Step",id:"how-it-works-step-by-step",level:3},{value:"Components Explained",id:"components-explained",level:3},{value:"Traffic Flow in Detail",id:"traffic-flow-in-detail",level:3},{value:"Practical Example: Three-Tier Architecture",id:"practical-example-three-tier-architecture",level:2},{value:"Installation Overview",id:"installation-overview",level:2},{value:"Common Commands",id:"common-commands",level:2},{value:"Checking Health",id:"checking-health",level:3},{value:"Viewing Services",id:"viewing-services",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Multicluster Operations",id:"multicluster-operations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Enable Injection Per Namespace",id:"1-enable-injection-per-namespace",level:3},{value:"2. Use Service Profiles",id:"2-use-service-profiles",level:3},{value:"3. Set Resource Limits",id:"3-set-resource-limits",level:3},{value:"4. Label Services for Export",id:"4-label-services-for-export",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Gateway Not Reachable",id:"gateway-not-reachable",level:3},{value:"Services Not Being Mirrored",id:"services-not-being-mirrored",level:3},{value:"mTLS Not Working",id:"mtls-not-working",level:3},{value:"What&#39;s Next?",id:"whats-next",level:2}];function u(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"linkerd-service-mesh",children:"Linkerd Service Mesh"})}),"\n",(0,s.jsx)(r.h2,{id:"what-is-a-service-mesh",children:"What is a Service Mesh?"}),"\n",(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.strong,{children:"service mesh"})," is a dedicated infrastructure layer that handles service-to-service communication in a microservices architecture. Instead of building communication logic into each service, the service mesh provides these capabilities transparently:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Secure communication"})," between services"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Traffic management"})," and routing"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Observability"})," into service behavior"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Reliability"})," features like retries and timeouts"]}),"\n"]}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    subgraph WithoutMesh[Without Service Mesh]\r\n        A1[Service A] --\x3e|Manual mTLS| B1[Service B]\r\n        A1 --\x3e|Manual Retry| C1[Service C]\r\n        B1 --\x3e|Manual Metrics| C1\r\n    end\r\n    \r\n    subgraph WithMesh[With Service Mesh]\r\n        A2[Service A]\r\n        B2[Service B]\r\n        C2[Service C]\r\n        Mesh[Service Mesh Layer]\r\n        \r\n        A2 -.-> Mesh\r\n        B2 -.-> Mesh\r\n        C2 -.-> Mesh\r\n        Mesh --\x3e|Automatic mTLS| A2\r\n        Mesh --\x3e|Automatic Retry| C2\r\n        Mesh --\x3e|Automatic Metrics| B2\r\n    end\r\n"}),"\n",(0,s.jsx)(r.p,{children:"The key insight: your application code doesn't change. The service mesh handles all the complexity."}),"\n",(0,s.jsx)(r.h2,{id:"why-linkerd",children:"Why Linkerd?"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Linkerd"})," is an ultra-light, security-first service mesh for Kubernetes. Compared to other service meshes:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Lightweight"}),": Minimal resource overhead (written in Rust)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Simple"}),": Works out of the box with zero configuration"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fast"}),": Sub-millisecond latency overhead"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Secure"}),": Automatic mTLS by default"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"CNCF"}),": Cloud Native Computing Foundation graduated project"]}),"\n"]}),"\n",(0,s.jsx)(r.admonition,{title:"Version",type:"info",children:(0,s.jsxs)(r.p,{children:["This guide uses ",(0,s.jsx)(r.strong,{children:"Linkerd stable-2.14.10"}),", a production-ready version optimized for multi-cluster deployments."]})}),"\n",(0,s.jsx)(r.h2,{id:"how-linkerd-works",children:"How Linkerd Works"}),"\n",(0,s.jsxs)(r.p,{children:["Linkerd operates using a ",(0,s.jsx)(r.strong,{children:"sidecar proxy pattern"}),". For every pod in your application, Linkerd automatically injects a lightweight proxy container that handles all network traffic."]}),"\n",(0,s.jsx)(r.h3,{id:"the-sidecar-pattern",children:"The Sidecar Pattern"}),"\n",(0,s.jsx)(r.mermaid,{value:"graph LR\r\n    subgraph Pod[Kubernetes Pod]\r\n        direction TB\r\n        App[Your Application]\r\n        Proxy[Linkerd Proxy]\r\n    end\r\n    \r\n    Client[Another Service] --\x3e|All traffic| Proxy\r\n    Proxy --\x3e|Filtered & Secured| App\r\n    App --\x3e|Response| Proxy\r\n    Proxy --\x3e|Metrics + mTLS| Client"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What happens:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Linkerd injects a proxy container into your pod"}),"\n",(0,s.jsx)(r.li,{children:"All network traffic (in and out) goes through the proxy"}),"\n",(0,s.jsx)(r.li,{children:"The proxy adds security, metrics, and reliability"}),"\n",(0,s.jsx)(r.li,{children:"Your application sees normal HTTP/gRPC traffic"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What your application doesn't need:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"No mTLS implementation"}),"\n",(0,s.jsx)(r.li,{children:"No retry logic"}),"\n",(0,s.jsx)(r.li,{children:"No metrics collection"}),"\n",(0,s.jsx)(r.li,{children:"No service discovery code"}),"\n",(0,s.jsx)(r.li,{children:"No load balancing logic"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"linkerd-architecture",children:"Linkerd Architecture"}),"\n",(0,s.jsxs)(r.p,{children:["Linkerd consists of two main parts: the ",(0,s.jsx)(r.strong,{children:"Control Plane"})," (brain) and the ",(0,s.jsx)(r.strong,{children:"Data Plane"})," (workers)."]}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    subgraph ControlPlane[Control Plane - Manages Everything]\r\n        Identity[Identity<br/>Issues Certificates]\r\n        Destination[Destination<br/>Service Discovery]\r\n        ProxyInjector[Proxy Injector<br/>Adds Proxies]\r\n    end\r\n    \r\n    subgraph DataPlane[Data Plane - Does the Work]\r\n        Pod1[Pod 1 + Proxy]\r\n        Pod2[Pod 2 + Proxy]\r\n        Pod3[Pod 3 + Proxy]\r\n    end\r\n    \r\n    Identity --\x3e|Certificate| Pod1\r\n    Identity --\x3e|Certificate| Pod2\r\n    Identity --\x3e|Certificate| Pod3\r\n    \r\n    Destination --\x3e|Endpoints| Pod1\r\n    Destination --\x3e|Endpoints| Pod2\r\n    Destination --\x3e|Endpoints| Pod3\r\n    \r\n    Pod1 <--\x3e|mTLS| Pod2\r\n    Pod2 <--\x3e|mTLS| Pod3"}),"\n",(0,s.jsx)(r.h3,{id:"control-plane-components",children:"Control Plane Components"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Component"}),(0,s.jsx)(r.th,{children:"What it Does"}),(0,s.jsx)(r.th,{children:"Why You Need It"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Identity"})}),(0,s.jsx)(r.td,{children:"Certificate authority that issues TLS certificates"}),(0,s.jsx)(r.td,{children:"Enables automatic mTLS between all services"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Destination"})}),(0,s.jsx)(r.td,{children:"Provides service discovery and routing information"}),(0,s.jsx)(r.td,{children:"Tells proxies where to send traffic"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Proxy Injector"})}),(0,s.jsx)(r.td,{children:"Automatically adds proxy containers to pods"}),(0,s.jsx)(r.td,{children:"No manual configuration needed"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"data-plane-the-proxy",children:"Data Plane: The Proxy"}),"\n",(0,s.jsxs)(r.p,{children:["Each pod gets a ",(0,s.jsx)(r.strong,{children:"Linkerd proxy"})," sidecar that:"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Intercepts all traffic"})," using iptables rules (set up by init container)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Encrypts connections"})," using mTLS certificates from Identity"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Routes requests"})," to healthy endpoints using info from Destination"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Collects metrics"})," (success rate, latency, request volume)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Provides reliability"})," (retries, timeouts, load balancing)"]}),"\n"]}),"\n",(0,s.jsx)(r.mermaid,{value:"sequenceDiagram\r\n    participant C as Client App\r\n    participant P1 as Client Proxy\r\n    participant P2 as Server Proxy\r\n    participant S as Server App\r\n    \r\n    C->>P1: HTTP Request\r\n    Note over P1: Add mTLS\r\n    P1->>P2: Encrypted Request\r\n    Note over P2: Verify Certificate\r\n    P2->>S: HTTP Request\r\n    S->>P2: HTTP Response\r\n    P2->>P1: Encrypted Response\r\n    P1->>C: HTTP Response\r\n    \r\n    Note over P1,P2: Both proxies collect metrics"}),"\n",(0,s.jsx)(r.h2,{id:"key-features-explained",children:"Key Features Explained"}),"\n",(0,s.jsx)(r.h3,{id:"1-automatic-mutual-tls-mtls",children:"1. Automatic Mutual TLS (mTLS)"}),"\n",(0,s.jsx)(r.p,{children:"Every service gets a unique identity and certificate. All communication is automatically encrypted."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"How it works:"})}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    subgraph Startup[When Pod Starts]\r\n        P1[Proxy starts]\r\n        P1 --\x3e|Request certificate| Identity[Identity CA]\r\n        Identity --\x3e|Issue cert| P1\r\n    end\r\n    \r\n    subgraph Communication[When Services Communicate]\r\n        S1[Service A Proxy] --\x3e|Present certificate| S2[Service B Proxy]\r\n        S2 --\x3e|Verify certificate| S1\r\n        S1 <--\x3e|Encrypted traffic| S2\r\n    end"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"\u2705 Zero-trust security: every connection authenticated"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Automatic encryption: no code changes needed"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Certificate rotation: happens automatically every 24 hours"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Compliance: meets requirements for encryption in transit"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"2-traffic-management",children:"2. Traffic Management"}),"\n",(0,s.jsx)(r.p,{children:"Control how requests flow between services."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Load Balancing:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Automatically distributes traffic across healthy pods"}),"\n",(0,s.jsx)(r.li,{children:"Removes unhealthy pods from rotation"}),"\n",(0,s.jsx)(r.li,{children:"Uses smart algorithms (EWMA - Exponentially Weighted Moving Average)"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Traffic Splitting:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:"# Send 90% traffic to v1, 10% to v2 (canary deployment)\r\napiVersion: split.smi-spec.io/v1alpha1\r\nkind: TrafficSplit\r\nmetadata:\r\n  name: my-service-split\r\nspec:\r\n  service: my-service\r\n  backends:\r\n  - service: my-service-v1\r\n    weight: 900\r\n  - service: my-service-v2\r\n    weight: 100\n"})}),"\n",(0,s.jsx)(r.h3,{id:"3-observability",children:"3. Observability"}),"\n",(0,s.jsx)(r.p,{children:"See what's happening in your system in real-time."}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Golden Metrics"})," (automatically collected):"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Success Rate"}),": % of requests that succeed"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Request Rate"}),": requests per second"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Latency"}),": how long requests take (P50, P95, P99)"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Access the dashboard:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"linkerd viz dashboard\n"})}),"\n",(0,s.jsx)(r.p,{children:"You'll see:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Service topology (which services talk to which)"}),"\n",(0,s.jsx)(r.li,{children:"Live traffic metrics"}),"\n",(0,s.jsx)(r.li,{children:"Error rates and types"}),"\n",(0,s.jsx)(r.li,{children:"Latency distributions"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"4-reliability",children:"4. Reliability"}),"\n",(0,s.jsx)(r.p,{children:"Make your services more resilient without changing code."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Automatic Retries:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:"# Retry failed requests automatically\r\napiVersion: linkerd.io/v1alpha2\r\nkind: ServiceProfile\r\nmetadata:\r\n  name: my-service\r\nspec:\r\n  routes:\r\n  - condition:\r\n      method: GET\r\n    name: GET /api/data\r\n    retries:\r\n      limit: 3\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Timeouts:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:"# Don't wait forever for responses\r\nspec:\r\n  routes:\r\n  - condition:\r\n      method: POST\r\n    name: POST /api/process\r\n    timeout: 10s\n"})}),"\n",(0,s.jsx)(r.h2,{id:"linkerd-components--extensions",children:"Linkerd Components & Extensions"}),"\n",(0,s.jsx)(r.p,{children:"Linkerd is modular. You install what you need."}),"\n",(0,s.jsx)(r.h3,{id:"core-components",children:"Core Components"}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsxs)(a.A,{value:"crds",label:"1. CRDs",default:!0,children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"What:"})," Custom Resource Definitions - extends Kubernetes API"]}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Install:"})}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"linkerd install --crds | kubectl apply -f -\n"})}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why:"})," Defines new Kubernetes resources like ",(0,s.jsx)(r.code,{children:"ServiceProfile"}),", ",(0,s.jsx)(r.code,{children:"TrafficSplit"}),", and ",(0,s.jsx)(r.code,{children:"Link"})]})]}),(0,s.jsxs)(a.A,{value:"control-plane",label:"2. Control Plane",children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"What:"})," The brain of Linkerd (Identity, Destination, Proxy Injector)"]}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Install:"})}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"linkerd install | kubectl apply -f -\n"})}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why:"})," Manages certificates, service discovery, and proxy injection"]})]}),(0,s.jsxs)(a.A,{value:"viz",label:"3. Linkerd Viz",children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"What:"})," Observability dashboard and metrics"]}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Install:"})}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"linkerd viz install | kubectl apply -f -\n"})}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Includes:"})}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Web dashboard"}),"\n",(0,s.jsx)(r.li,{children:"Prometheus (metrics storage)"}),"\n",(0,s.jsx)(r.li,{children:"Grafana (visualization)"}),"\n",(0,s.jsx)(r.li,{children:"Tap (live traffic inspection)"}),"\n"]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why:"})," See what's happening in your mesh"]})]}),(0,s.jsxs)(a.A,{value:"multicluster",label:"4. Multicluster",children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"What:"})," Connect services across multiple Kubernetes clusters"]}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Install:"})}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"linkerd multicluster install | kubectl apply -f -\n"})}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Provides:"})}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Gateway (secure tunnel between clusters)"}),"\n",(0,s.jsx)(r.li,{children:"Service Mirror (automatic service discovery)"}),"\n"]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why:"})," Essential for cloud-fog-edge architecture"]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"multi-cluster-communication",children:"Multi-Cluster Communication"}),"\n",(0,s.jsx)(r.p,{children:"This is where Linkerd becomes powerful for cloud-fog-edge architectures."}),"\n",(0,s.jsx)(r.h3,{id:"the-problem",children:"The Problem"}),"\n",(0,s.jsx)(r.p,{children:"You have services in different Kubernetes clusters that need to talk to each other:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Edge cluster needs to access Fog services"}),"\n",(0,s.jsx)(r.li,{children:"Fog cluster needs to access Cloud services"}),"\n"]}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    EdgeCluster[Edge Cluster]\r\n    FogCluster[Fog Cluster]\r\n    CloudCluster[Cloud Cluster]\r\n    \r\n    EdgeCluster -.->|How to connect?| FogCluster\r\n    FogCluster -.->|How to connect?| CloudCluster"}),"\n",(0,s.jsx)(r.h3,{id:"the-solution-linkerd-multicluster",children:"The Solution: Linkerd Multicluster"}),"\n",(0,s.jsx)(r.p,{children:"Linkerd creates secure tunnels between clusters and mirrors services automatically."}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    subgraph ClusterA[Cluster A - Edge]\r\n        AppA[My App]\r\n        MirrorB[hello-clusterB<br/>Mirror Service]\r\n        GatewayA[Gateway]\r\n    end\r\n    \r\n    subgraph ClusterB[Cluster B - Fog]\r\n        GatewayB[Gateway<br/>LoadBalancer IP]\r\n        ServiceB[hello<br/>Real Service]\r\n    end\r\n    \r\n    AppA --\x3e|1. Call| MirrorB\r\n    MirrorB --\x3e|2. Forward| GatewayA\r\n    GatewayA <--\x3e|3. Secure Tunnel| GatewayB\r\n    GatewayB --\x3e|4. Route| ServiceB\r\n    ServiceB --\x3e|5. Response| GatewayB"}),"\n",(0,s.jsx)(r.h3,{id:"how-it-works-step-by-step",children:"How It Works: Step by Step"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Step 1: Mark Services for Export"})}),"\n",(0,s.jsx)(r.p,{children:"In Cluster B (target), label services you want to share:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl label service hello -n my-namespace to-export=true\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Step 2: Link Clusters"})}),"\n",(0,s.jsx)(r.p,{children:"Connect Cluster A (source) to Cluster B (target):"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# This creates the Link resource in Cluster A\r\nlinkerd multicluster link --cluster-name clusterB | kubectl apply -f -\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Step 3: Automatic Service Mirroring"})}),"\n",(0,s.jsx)(r.p,{children:"Linkerd automatically creates mirror services in Cluster A:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Original: ",(0,s.jsx)(r.code,{children:"hello"})," (in Cluster B)"]}),"\n",(0,s.jsxs)(r.li,{children:["Mirror: ",(0,s.jsx)(r.code,{children:"hello-clusterB"})," (in Cluster A)"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Step 4: Use the Service"})}),"\n",(0,s.jsx)(r.p,{children:"Your application in Cluster A calls it like any other service:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"curl http://hello-clusterB:8080\n"})}),"\n",(0,s.jsx)(r.h3,{id:"components-explained",children:"Components Explained"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Component"}),(0,s.jsx)(r.th,{children:"Location"}),(0,s.jsx)(r.th,{children:"Purpose"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Gateway"})}),(0,s.jsx)(r.td,{children:"Target Cluster"}),(0,s.jsx)(r.td,{children:"LoadBalancer service that accepts incoming cross-cluster traffic"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Service Mirror Controller"})}),(0,s.jsx)(r.td,{children:"Source Cluster"}),(0,s.jsx)(r.td,{children:"Watches target cluster and creates mirror services"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Link Resource"})}),(0,s.jsx)(r.td,{children:"Source Cluster"}),(0,s.jsx)(r.td,{children:"Configuration defining connection to target cluster"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Probe Service"})}),(0,s.jsx)(r.td,{children:"Source Cluster"}),(0,s.jsx)(r.td,{children:"Health checks gateway connectivity"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"traffic-flow-in-detail",children:"Traffic Flow in Detail"}),"\n",(0,s.jsx)(r.mermaid,{value:"sequenceDiagram\r\n    participant App as Application<br/>(Cluster A)\r\n    participant DNS as CoreDNS\r\n    participant Mirror as Mirror Service\r\n    participant GW_A as Gateway A\r\n    participant GW_B as Gateway B\r\n    participant Svc as Real Service<br/>(Cluster B)\r\n    \r\n    App->>DNS: Resolve hello-clusterB\r\n    DNS->>App: Return ClusterIP\r\n    \r\n    App->>Mirror: HTTP Request\r\n    Note over Mirror: Local Kubernetes Service\r\n    \r\n    Mirror->>GW_A: Forward to Gateway\r\n    Note over GW_A: Proxy adds mTLS\r\n    \r\n    GW_A->>GW_B: Encrypted Request\r\n    Note over GW_A,GW_B: Secure Tunnel<br/>Port 4143\r\n    \r\n    Note over GW_B: Verify Certificate\r\n    GW_B->>Svc: Forward Request\r\n    \r\n    Svc->>GW_B: Response\r\n    GW_B->>GW_A: Encrypted Response\r\n    GW_A->>Mirror: Forward Response\r\n    Mirror->>App: HTTP Response"}),"\n",(0,s.jsx)(r.h2,{id:"practical-example-three-tier-architecture",children:"Practical Example: Three-Tier Architecture"}),"\n",(0,s.jsx)(r.p,{children:"Let's see how this works in a cloud-fog-edge setup."}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    subgraph Edge[Edge Cluster - User Facing]\r\n        Frontend[Frontend Service]\r\n        API_Mirror_Fog[api-fog<br/>Mirror]\r\n    end\r\n    \r\n    subgraph Fog[Fog Cluster - Regional Processing]\r\n        API[API Service]\r\n        DB_Mirror_Cloud[database-cloud<br/>Mirror]\r\n    end\r\n    \r\n    subgraph Cloud[Cloud Cluster - Centralized Data]\r\n        Database[Database Service]\r\n    end\r\n    \r\n    Frontend --\x3e|Calls| API_Mirror_Fog\r\n    API_Mirror_Fog -.->|Via Gateway| API\r\n    \r\n    API --\x3e|Calls| DB_Mirror_Cloud\r\n    DB_Mirror_Cloud -.->|Via Gateway| Database"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Request Flow:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"User hits Frontend (Edge)"}),"\n",(0,s.jsxs)(r.li,{children:["Frontend calls ",(0,s.jsx)(r.code,{children:"api-fog"})," service"]}),"\n",(0,s.jsx)(r.li,{children:"Request routes through Edge\u2192Fog gateway tunnel"}),"\n",(0,s.jsx)(r.li,{children:"API in Fog processes request"}),"\n",(0,s.jsxs)(r.li,{children:["API calls ",(0,s.jsx)(r.code,{children:"database-cloud"})," service"]}),"\n",(0,s.jsx)(r.li,{children:"Request routes through Fog\u2192Cloud gateway tunnel"}),"\n",(0,s.jsx)(r.li,{children:"Database in Cloud responds"}),"\n",(0,s.jsx)(r.li,{children:"Response flows back: Cloud\u2192Fog\u2192Edge\u2192User"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What Linkerd Handles:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"\u2705 Service discovery across clusters"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Automatic mTLS encryption"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Load balancing across replicas"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Metrics collection at each hop"}),"\n",(0,s.jsx)(r.li,{children:"\u2705 Automatic retries if requests fail"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"installation-overview",children:"Installation Overview"}),"\n",(0,s.jsx)(r.p,{children:"Here's the complete installation flow (detailed steps in hands-on guides):"}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TB\r\n    Start[Start] --\x3e PreCheck[linkerd check --pre]\r\n    PreCheck --\x3e CRDs[Install CRDs]\r\n    CRDs --\x3e ControlPlane[Install Control Plane]\r\n    ControlPlane --\x3e Verify[linkerd check]\r\n    Verify --\x3e Viz[Install Viz]\r\n    Viz --\x3e VizCheck[linkerd viz check]\r\n    VizCheck --\x3e Multi[Install Multicluster]\r\n    Multi --\x3e MultiCheck[linkerd multicluster check]\r\n    MultiCheck --\x3e Done[Ready to Link Clusters]"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Commands:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# 1. Install CLI\r\ncurl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/install | sh\r\n\r\n# 2. Validate\r\nlinkerd check --pre\r\n\r\n# 3. Install Linkerd\r\nlinkerd install --crds | kubectl apply -f -\r\nlinkerd install | kubectl apply -f -\r\nlinkerd check\r\n\r\n# 4. Install Viz\r\nlinkerd viz install | kubectl apply -f -\r\nlinkerd viz check\r\n\r\n# 5. Install Multicluster\r\nlinkerd multicluster install | kubectl apply -f -\r\nlinkerd multicluster check\n"})}),"\n",(0,s.jsx)(r.h2,{id:"common-commands",children:"Common Commands"}),"\n",(0,s.jsx)(r.h3,{id:"checking-health",children:"Checking Health"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check control plane\r\nlinkerd check\r\n\r\n# Check data plane proxies\r\nlinkerd check --proxy\r\n\r\n# Check multicluster\r\nlinkerd multicluster check\n"})}),"\n",(0,s.jsx)(r.h3,{id:"viewing-services",children:"Viewing Services"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# See all meshed services\r\nlinkerd viz stat deploy -n my-namespace\r\n\r\n# View service details\r\nlinkerd viz stat deploy/my-service\r\n\r\n# View endpoints\r\nlinkerd viz endpoints my-service\n"})}),"\n",(0,s.jsx)(r.h3,{id:"debugging",children:"Debugging"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# View proxy logs\r\nkubectl logs <pod-name> -c linkerd-proxy\r\n\r\n# Tap live traffic\r\nlinkerd viz tap deploy/my-service\r\n\r\n# Check what's being injected\r\nlinkerd inject deployment.yaml | less\n"})}),"\n",(0,s.jsx)(r.h3,{id:"multicluster-operations",children:"Multicluster Operations"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# View cluster links\r\nlinkerd multicluster list\r\n\r\n# Check gateways\r\nlinkerd multicluster gateways\r\n\r\n# View exported services\r\nkubectl get services -l to-export=true --all-namespaces\n"})}),"\n",(0,s.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(r.h3,{id:"1-enable-injection-per-namespace",children:"1. Enable Injection Per Namespace"}),"\n",(0,s.jsx)(r.p,{children:"Don't inject everything. Be selective:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Enable automatic injection for a namespace\r\nkubectl annotate namespace my-app linkerd.io/inject=enabled\r\n\r\n# Deploy - proxies are automatically added\r\nkubectl apply -f my-app.yaml -n my-app\n"})}),"\n",(0,s.jsx)(r.h3,{id:"2-use-service-profiles",children:"2. Use Service Profiles"}),"\n",(0,s.jsx)(r.p,{children:"Define expected behavior for better reliability:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:"apiVersion: linkerd.io/v1alpha2\r\nkind: ServiceProfile\r\nmetadata:\r\n  name: my-service.my-namespace.svc.cluster.local\r\nspec:\r\n  routes:\r\n  - name: GET /api/users\r\n    condition:\r\n      method: GET\r\n      pathRegex: /api/users\r\n    timeout: 5s\r\n    retries:\r\n      limit: 3\n"})}),"\n",(0,s.jsx)(r.h3,{id:"3-set-resource-limits",children:"3. Set Resource Limits"}),"\n",(0,s.jsx)(r.p,{children:"Proxies are lightweight but still need limits:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:'annotations:\r\n  config.linkerd.io/proxy-cpu-limit: "1"\r\n  config.linkerd.io/proxy-cpu-request: "100m"\r\n  config.linkerd.io/proxy-memory-limit: "250Mi"\r\n  config.linkerd.io/proxy-memory-request: "20Mi"\n'})}),"\n",(0,s.jsx)(r.h3,{id:"4-label-services-for-export",children:"4. Label Services for Export"}),"\n",(0,s.jsx)(r.p,{children:"Be explicit about what crosses cluster boundaries:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Only export what needs to be accessed from other clusters\r\nkubectl label service api to-export=true\r\nkubectl label service internal-worker to-export=false\n"})}),"\n",(0,s.jsx)(r.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(r.h3,{id:"gateway-not-reachable",children:"Gateway Not Reachable"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check gateway has LoadBalancer IP\r\nkubectl get svc -n linkerd-multicluster\r\n\r\n# Check gateway pod is running\r\nkubectl get pods -n linkerd-multicluster -l app=linkerd-gateway\r\n\r\n# Test connectivity from source cluster\r\nkubectl exec -it <pod> -- curl -v http://gateway-ip:4143/health\n"})}),"\n",(0,s.jsx)(r.h3,{id:"services-not-being-mirrored",children:"Services Not Being Mirrored"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check service mirror controller logs\r\nkubectl logs -n linkerd-multicluster -l component=controller\r\n\r\n# Verify Link resource exists\r\nkubectl get links -A\r\n\r\n# Check service has export label\r\nkubectl get svc <service-name> -o yaml | grep to-export\n"})}),"\n",(0,s.jsx)(r.h3,{id:"mtls-not-working",children:"mTLS Not Working"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check Identity certificates\r\nlinkerd identity\r\n\r\n# View certificate expiration\r\nkubectl get secret -n linkerd linkerd-identity-issuer -o yaml\r\n\r\n# Check proxy can reach Identity\r\nkubectl logs <pod> -c linkerd-proxy | grep identity\n"})}),"\n",(0,s.jsx)(r.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,s.jsx)(r.p,{children:"Now that you understand Linkerd:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/docs/local-setup/traffic-splits",children:"Traffic Splits"})})," - Learn how to split traffic between services"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/docs/local-setup/k3s-k3d",children:"K3s & K3d"})})," - Understand the Kubernetes distribution we'll use"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/docs/local-setup/creating-clusters",children:"Creating Clusters"})})," - Build your multi-cluster environment"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/docs/local-setup/installing-linkerd",children:"Installing Linkerd"})})," - Hands-on installation guide"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.a,{href:"/docs/local-setup/linking-clusters",children:"Linking Clusters"})})," - Connect your clusters together"]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Resources:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://linkerd.io/2.14/overview/",children:"Official Linkerd Docs"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://linkerd.io/2.14/reference/architecture/",children:"Linkerd Architecture Deep Dive"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://linkerd.io/2.14/features/multicluster/",children:"Multicluster Guide"})}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},9365:(e,r,n)=>{n.d(r,{A:()=>l});n(6540);var i=n(4164);const s={tabItem:"tabItem_Ymn6"};var t=n(4848);function l({children:e,hidden:r,className:n}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,i.A)(s.tabItem,n),hidden:r,children:e})}}}]);