"use strict";(globalThis.webpackChunkdefogv_2_wiki=globalThis.webpackChunkdefogv_2_wiki||[]).push([[7221],{8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>c});var i=n(6540);const s={},t=i.createContext(s);function o(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:r},e.children)}},8755:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"architecture/overview","title":"Architecture Overview","description":"An overview of Defog v2\'s distributed multi-cluster architecture and its core components.","source":"@site/docs/architecture/overview.mdx","sourceDirName":"architecture","slug":"/architecture/overview","permalink":"/defogv2-wiki/docs/architecture/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/aprountzos/defogv2-wiki/tree/main/docs/docs/architecture/overview.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Architecture Overview","description":"An overview of Defog v2\'s distributed multi-cluster architecture and its core components.","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Complete Data Flows","permalink":"/defogv2-wiki/docs/architecture/data-flow"},"next":{"title":"API Reference","permalink":"/defogv2-wiki/docs/architecture/api-reference"}}');var s=n(4848),t=n(8453);const o={title:"Architecture Overview",description:"An overview of Defog v2's distributed multi-cluster architecture and its core components.",sidebar_position:2},c="Architecture Overview",l={},a=[{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"Core Principles",id:"core-principles",level:3},{value:"High-Level Architecture",id:"high-level-architecture",level:2},{value:"Service Components",id:"service-components",level:2},{value:"1. Discovery Controller",id:"1-discovery-controller",level:3},{value:"2. Metrics Monitor",id:"2-metrics-monitor",level:3},{value:"3. Scheduler",id:"3-scheduler",level:3},{value:"4. Orchestrator (The Brain)",id:"4-orchestrator-the-brain",level:3},{value:"5. Executor",id:"5-executor",level:3},{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Internal Communication",id:"internal-communication",level:3},{value:"Peer Communication",id:"peer-communication",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"architecture-overview",children:"Architecture Overview"})}),"\n",(0,s.jsx)(r.p,{children:"Defog v2 is a distributed multi-cluster workload management system that intelligently distributes services across Kubernetes clusters using Linkerd multi-cluster capabilities."}),"\n",(0,s.jsx)(r.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,s.jsxs)(r.p,{children:["Each cluster operates ",(0,s.jsx)(r.strong,{children:"independently"})," with its own decision-making process. There is no centralized controller\u2014clusters communicate peer-to-peer only when necessary."]}),"\n",(0,s.jsx)(r.h3,{id:"core-principles",children:"Core Principles"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Autonomous Operation"}),": Each cluster runs the same services and makes its own decisions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Dual-Strategy Approach"}),": Combines stress-based traffic management with RPS-based service placement"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Minimal Peer Communication"}),": Clusters only communicate when local resources are exhausted"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Gradual Traffic Shifting"}),": Changes happen incrementally to avoid service disruption"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"high-level-architecture",children:"High-Level Architecture"}),"\n",(0,s.jsx)(r.mermaid,{value:'graph LR\r\n    subgraph "Cluster A"\r\n        DC1[Discovery Controller]\r\n        MON1[Metrics Monitor]\r\n        SCHED1[Scheduler]\r\n        ORCH1[Orchestrator]\r\n        EXEC1[Executor]\r\n        \r\n        MON1 --\x3e|stress events| ORCH1\r\n        MON1 --\x3e|RPS events| ORCH1\r\n        ORCH1 --\x3e|decisions needed| SCHED1\r\n        SCHED1 --\x3e|placement decision| ORCH1\r\n        ORCH1 --\x3e|execute actions| EXEC1\r\n        DC1 -.->|label services| EXEC1\r\n    end\r\n    \r\n    subgraph "Cluster B"\r\n        DC2[Discovery Controller]\r\n        MON2[Metrics Monitor]\r\n        SCHED2[Scheduler]\r\n        ORCH2[Orchestrator]\r\n        EXEC2[Executor]\r\n        \r\n        MON2 --\x3e|stress events| ORCH2\r\n        MON2 --\x3e|RPS events| ORCH2\r\n        ORCH2 --\x3e|decisions needed| SCHED2\r\n        SCHED2 --\x3e|placement decision| ORCH2\r\n        ORCH2 --\x3e|execute actions| EXEC2\r\n        DC2 -.->|label services| EXEC2\r\n    end\r\n    \r\n    ORCH1 <--\x3e|peer API| EXEC2\r\n    ORCH2 <--\x3e|peer API| EXEC1\r\n    \r\n    K8S1[(Kubernetes API)] <--\x3e EXEC1\r\n    K8S2[(Kubernetes API)] <--\x3e EXEC2\r\n    \r\n    style ORCH1 fill:#e1f5ff\r\n    style ORCH2 fill:#e1f5ff\r\n    style EXEC1 fill:#ffe1e1\r\n    style EXEC2 fill:#ffe1e1'}),"\n",(0,s.jsx)(r.h2,{id:"service-components",children:"Service Components"}),"\n",(0,s.jsx)(r.h3,{id:"1-discovery-controller",children:"1. Discovery Controller"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Purpose"}),": Ensures services are properly labeled for Linkerd multi-cluster export"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Responsibilities"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Watches Service resources in specified namespaces"}),"\n",(0,s.jsxs)(r.li,{children:["Adds required labels (",(0,s.jsx)(r.code,{children:'mirror.linkerd.io/exported: "true"'}),")"]}),"\n",(0,s.jsx)(r.li,{children:"Emits events when services are labeled"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why Separate"}),": Pure Kubernetes reconciliation logic\u2014idempotent and isolated"]}),"\n",(0,s.jsx)(r.h3,{id:"2-metrics-monitor",children:"2. Metrics Monitor"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Purpose"}),": Collects and analyzes service metrics for both strategies"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Responsibilities"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Stress Monitoring"}),": Tracks pod CPU/RAM usage vs limits"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"RPS Monitoring"}),": Tracks requests per second for all services"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Capacity Monitoring"}),": Calculates available cluster resources"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Event Emission"}),": Triggers events when thresholds are crossed"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why Separate"}),": Metrics collection is compute-intensive and should be isolated from control logic"]}),"\n",(0,s.jsx)(r.h3,{id:"3-scheduler",children:"3. Scheduler"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Purpose"}),": Makes placement and eviction decisions using pluggable algorithms"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Responsibilities"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Stress Algorithm"}),": Calculates traffic split percentages"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"RPS-LFU Algorithm"}),": Determines which services to deploy/delete"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Pure Logic"}),": No side effects\u2014only returns decisions"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why Separate"}),": Business logic without side effects makes testing and algorithm swapping easier"]}),"\n",(0,s.jsx)(r.h3,{id:"4-orchestrator-the-brain",children:"4. Orchestrator (The Brain)"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Purpose"}),": Coordinates all decisions and peer communication"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Responsibilities"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Receives events from Monitor"}),"\n",(0,s.jsx)(r.li,{children:"Consults Scheduler for decisions"}),"\n",(0,s.jsx)(r.li,{children:"Commands Executor to take actions"}),"\n",(0,s.jsx)(r.li,{children:"Communicates with peer clusters"}),"\n",(0,s.jsx)(r.li,{children:"Maintains state of deployments and traffic splits"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why Separate"}),": Single point of coordination\u2014easier to reason about cross-cluster state"]}),"\n",(0,s.jsx)(r.h3,{id:"5-executor",children:"5. Executor"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Purpose"}),": Executes Kubernetes operations and provides peer API"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Responsibilities"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Creates/deletes Deployments"}),"\n",(0,s.jsx)(r.li,{children:"Updates TrafficSplit CRDs"}),"\n",(0,s.jsx)(r.li,{children:"Scales workloads"}),"\n",(0,s.jsx)(r.li,{children:"Exposes API for peer clusters"}),"\n",(0,s.jsx)(r.li,{children:"Validates operations before execution"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Why Separate"}),": Isolates all Kubernetes operations\u2014provides clean API boundary"]}),"\n",(0,s.jsx)(r.h2,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,s.jsx)(r.h3,{id:"internal-communication",children:"Internal Communication"}),"\n",(0,s.jsx)(r.mermaid,{value:"sequenceDiagram\r\n    participant M as Monitor\r\n    participant O as Orchestrator\r\n    participant S as Scheduler\r\n    participant E as Executor\r\n    \r\n    M->>O: StressEvent (pod overloaded)\r\n    O->>S: Calculate traffic split\r\n    S--\x3e>O: Split decision (70/30)\r\n    O->>E: Update TrafficSplit\r\n    E--\x3e>O: Success\r\n    \r\n    Note over M,E: Stress strategy - immediate relief\r\n    \r\n    M->>O: HighRPSEvent (mirrored service)\r\n    O->>S: Should deploy locally?\r\n    S--\x3e>O: Yes, deploy\r\n    O->>E: Create deployment\r\n    E--\x3e>O: Deployed\r\n    O->>E: Update TrafficSplit (100/0)\r\n    \r\n    Note over M,E: RPS strategy - long-term optimization"}),"\n",(0,s.jsx)(r.h3,{id:"peer-communication",children:"Peer Communication"}),"\n",(0,s.jsx)(r.mermaid,{value:'sequenceDiagram\r\n    participant O1 as Orchestrator<br/>(Cluster A)\r\n    participant E1 as Executor<br/>(Cluster A)\r\n    participant E2 as Executor<br/>(Cluster B)\r\n    participant O2 as Orchestrator<br/>(Cluster B)\r\n    \r\n    Note over O1: High RPS on mirrored service<br/>No local capacity\r\n    \r\n    O1->>E2: POST /peer/v1/can-deploy<br/>{service, resources, RPS}\r\n    E2->>O2: Check capacity & LFU\r\n    O2--\x3e>E2: Decision\r\n    E2--\x3e>O1: {"status": "will_deploy"}\r\n    \r\n    Note over E2,O2: Deploy service locally\r\n    \r\n    E2->>E2: Create deployment\r\n    E2--\x3e>O1: Deployment confirmation\r\n    \r\n    Note over O1: Update traffic routing\r\n    O1->>E1: Update TrafficSplit<br/>(route to Cluster B)'})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);